// Generated by Copilot

import React, {
  useState,
  useEffect,
  useRef,
  useReducer,
  useCallback,
  useMemo,
  ChangeEvent,
  FormEvent,
  MouseEvent,
} from "react";
import {
  Todo,
  User,
  Notification,
  HistoryAction,
  HistoryState,
} from "./types";
import Notifications from "./Notifications";
import TodoList from "./TodoList";
import UserList from "./UserList";
import useTimer from "./hooks/useTimer";
import useApiData from "./hooks/useApiData";

/**
 * Reducer for undo/redo history state.
 * @param state - Current history state
 * @param action - Action to perform
 * @returns Updated history state
 * Generated by Copilot
 */
function historyReducer(state: HistoryState, action: HistoryAction): HistoryState {
  switch (action.type) {
    case "add":
      return {
        past: [...state.past, state.present],
        present: action.value,
        future: [],
      };
    case "undo":
      if (state.past.length === 0) return state;
      return {
        past: state.past.slice(0, -1),
        present: state.past[state.past.length - 1],
        future: [state.present, ...state.future],
      };
    case "redo":
      if (state.future.length === 0) return state;
      return {
        past: [...state.past, state.present],
        present: state.future[0],
        future: state.future.slice(1),
      };
    default:
      return state;
  }
}

/**
 * MegaComponent demonstrates a large set of UI patterns and state management.
 * Generated by Copilot
 */
const MegaComponent: React.FC = () => {
  // State hooks
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");
  const [items, setItems] = useState<string[]>([]);
  const [filter, setFilter] = useState("");
  const [theme, setTheme] = useState<"light" | "dark">("light");
  const [modalOpen, setModalOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const timer = useTimer(); // Generated by Copilot
  const [selected, setSelected] = useState<number | null>(null);
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [form, setForm] = useState({ name: "", email: "" });
  const [showHistory, setShowHistory] = useState(false);
  const [tab, setTab] = useState<"home" | "list" | "settings" | "users" | "todos">("home");
  const [checked, setChecked] = useState(false);
  const [progress, setProgress] = useState(0);
  const [avatar, setAvatar] = useState<string | null>(null);
  const { apiData, loading: apiLoading, error, fetchApiData } = useApiData(); // Generated by Copilot
  const [users, setUsers] = useState<User[]>([]);
  const [todos, setTodos] = useState<Todo[]>([]);
  const [todoText, setTodoText] = useState("");
  const [showTodos, setShowTodos] = useState(true);
  const [showUsers, setShowUsers] = useState(true);
  const [editUserId, setEditUserId] = useState<number | null>(null);
  const [editUser, setEditUser] = useState<User>({ id: 0, name: "", email: "" });
  const [searchUser, setSearchUser] = useState("");
  const [searchTodo, setSearchTodo] = useState("");
  const [bulkSelect, setBulkSelect] = useState<number[]>([]);
  const [showBulkActions, setShowBulkActions] = useState(false);
  const [showNotifications, setShowNotifications] = useState(true);

  // Reducer for undo/redo
  const [historyState, dispatchHistory] = useReducer(historyReducer, {
    past: [],
    present: "",
    future: [],
  });

  // Refs
  const inputRef = useRef<HTMLInputElement>(null);

  // Effects
  useEffect(() => {
    setLoading(true);
    setTimeout(() => {
      setItems(["Alpha", "Beta", "Gamma", "Delta"]);
      setUsers([
        { id: 1, name: "Alice", email: "alice@example.com" },
        { id: 2, name: "Bob", email: "bob@example.com" },
        { id: 3, name: "Charlie", email: "charlie@example.com" }
      ]);
      setTodos([
        { id: 1, text: "Learn React", completed: false },
        { id: 2, text: "Build a project", completed: true },
        { id: 3, text: "Refactor code", completed: false }
      ]);
      setLoading(false);
    }, 1000);

    return () => {
      // Cleanup if needed
    };
  }, []);

  useEffect(() => {
    if (progress < 100) {
      const id = setTimeout(() => setProgress(progress + 10), 500);
      return () => clearTimeout(id);
    }
  }, [progress]);

  useEffect(() => {
    if (theme === "dark") {
      document.body.style.background = "#222";
      document.body.style.color = "#fff";
    } else {
      document.body.style.background = "#fff";
      document.body.style.color = "#222";
    }
    return () => {
      document.body.style.background = "";
      document.body.style.color = "";
    };
  }, [theme]);

  // Memoized values
  const filteredItems = useMemo(
    () => items.filter((item) => item.toLowerCase().includes(filter.toLowerCase())),
    [items, filter]
  );
  const filteredUsers = useMemo(
    () => users.filter((u) =>
      u.name.toLowerCase().includes(searchUser.toLowerCase()) ||
      u.email.toLowerCase().includes(searchUser.toLowerCase())
    ),
    [users, searchUser]
  );
  const filteredTodos = useMemo(
    () => todos.filter((t) => t.text.toLowerCase().includes(searchTodo.toLowerCase())),
    [todos, searchTodo]
  );

  // Callbacks
  const handleAddItem = useCallback(() => {
    if (text.trim()) {
      setItems((prev) => [...prev, text]);
      setText("");
      setNotifications((n) => [
        ...n,
        { id: Date.now(), message: `Added: ${text}`, type: "info" }
      ]);
      dispatchHistory({ type: "add", value: text });
    }
  }, [text]);

  const handleRemoveItem = useCallback(
    (idx: number) => {
      setItems((prev) => prev.filter((_, i) => i !== idx));
      setNotifications((n) => [
        ...n,
        { id: Date.now(), message: `Removed item at index ${idx}`, type: "warning" }
      ]);
    },
    []
  );

  const handleFormChange = (e: ChangeEvent<HTMLInputElement>) => {
    setForm({ ...form, [e.target.name]: e.target.value });
  };

  const handleFormSubmit = (e: FormEvent) => {
    e.preventDefault();
    setNotifications((n) => [
      ...n,
      { id: Date.now(), message: `Form submitted: ${form.name}, ${form.email}`, type: "info" }
    ]);
    setForm({ name: "", email: "" });
  };

  const handleThemeToggle = () => setTheme((t) => (t === "light" ? "dark" : "light"));

  const handleTabChange = (tab: typeof tab) => setTab(tab);

  const handleAvatarUpload = (e: ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const reader = new FileReader();
      reader.onload = (ev) => setAvatar(ev.target?.result as string);
      reader.readAsDataURL(e.target.files[0]);
    }
  };

  // User management
  const handleEditUser = (user: User) => {
    setEditUserId(user.id);
    setEditUser(user);
  };

  const handleEditUserChange = (e: ChangeEvent<HTMLInputElement>) => {
    setEditUser({ ...editUser, [e.target.name]: e.target.value });
  };

  const handleSaveUser = () => {
    setUsers((prev) =>
      prev.map((u) => (u.id === editUserId ? { ...editUser } : u))
    );
    setEditUserId(null);
    setEditUser({ id: 0, name: "", email: "" });
    setNotifications((n) => [
      ...n,
      { id: Date.now(), message: `User updated: ${editUser.name}`, type: "info" }
    ]);
  };

  const handleDeleteUser = (id: number) => {
    setUsers((prev) => prev.filter((u) => u.id !== id));
    setNotifications((n) => [
      ...n,
      { id: Date.now(), message: `User deleted: ${id}`, type: "warning" }
    ]);
  };

  // Todo management
  const handleAddTodo = () => {
    if (todoText.trim()) {
      setTodos((prev) => [
        ...prev,
        { id: Date.now(), text: todoText, completed: false }
      ]);
      setTodoText("");
      setNotifications((n) => [
        ...n,
        { id: Date.now(), message: `Todo added: ${todoText}`, type: "info" }
      ]);
    }
  };

  const handleToggleTodo = (id: number) => {
    setTodos((prev) =>
      prev.map((t) =>
        t.id === id ? { ...t, completed: !t.completed } : t
      )
    );
    setNotifications((n) => [
      ...n,
      { id: Date.now(), message: `Todo toggled: ${id}`, type: "info" }
    ]);
  };

  const handleDeleteTodo = (id: number) => {
    setTodos((prev) => prev.filter((t) => t.id !== id));
    setNotifications((n) => [
      ...n,
      { id: Date.now(), message: `Todo deleted: ${id}`, type: "warning" }
    ]);
  };

  // Bulk actions
  const handleBulkSelect = (id: number) => {
    setBulkSelect((prev) =>
      prev.includes(id) ? prev.filter((i) => i !== id) : [...prev, id]
    );
  };

  const handleBulkDelete = () => {
    setTodos((prev) => prev.filter((t) => !bulkSelect.includes(t.id)));
    setBulkSelect([]);
    setShowBulkActions(false);
    setNotifications((n) => [
      ...n,
      { id: Date.now(), message: `Bulk deleted todos`, type: "warning" }
    ]);
  };

  // Render
  return (
    <div className={`mega-component ${theme}`}>
      <h1>MegaComponent</h1>
      <div>
        <button onClick={handleThemeToggle}>Toggle Theme</button>
        <span>Current theme: {theme}</span>
      </div>
      <div>
        <button onClick={() => setModalOpen(true)}>Open Modal</button>
        {modalOpen && (
          <div className="modal">
            <h2>Modal Dialog</h2>
            <button onClick={() => setModalOpen(false)}>Close</button>
          </div>
        )}
      </div>
      <div>
        <h2>Counter</h2>
        <button onClick={() => setCount((c) => c - 1)}>-</button>
        <span>{count}</span>
        <button onClick={() => setCount((c) => c + 1)}>+</button>
      </div>
      <div>
        <h2>Timer: {timer}s</h2>
      </div>
      <div>
        <h2>Progress</h2>
        <progress value={progress} max={100} />
      </div>
      <div>
        <h2>Notifications</h2>
        <Notifications
          notifications={notifications}
          show={showNotifications}
          onToggle={() => setShowNotifications((s) => !s)}
        />
      </div>
      <div>
        <h2>Tabs</h2>
        <button onClick={() => handleTabChange("home")}>Home</button>
        <button onClick={() => handleTabChange("list")}>List</button>
        <button onClick={() => handleTabChange("settings")}>Settings</button>
        <button onClick={() => handleTabChange("users")}>Users</button>
        <button onClick={() => handleTabChange("todos")}>Todos</button>
        <div>
          {tab === "home" && <div>Welcome Home!</div>}
          {tab === "list" && (
            <div>
              <input
                ref={inputRef}
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="Add item"
              />
              <button onClick={handleAddItem}>Add</button>
              <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                placeholder="Filter"
              />
              <ul>
                {filteredItems.map((item, idx) => (
                  <li key={idx}>
                    <span
                      style={{
                        fontWeight: selected === idx ? "bold" : "normal",
                        cursor: "pointer",
                      }}
                      onClick={() => setSelected(idx)}
                    >
                      {item}
                    </span>
                    <button onClick={() => handleRemoveItem(idx)}>Remove</button>
                  </li>
                ))}
              </ul>
            </div>
          )}
          {tab === "settings" && (
            <div>
              <form onSubmit={handleFormSubmit}>
                <input
                  name="name"
                  value={form.name}
                  onChange={handleFormChange}
                  placeholder="Name"
                />
                <input
                  name="email"
                  value={form.email}
                  onChange={handleFormChange}
                  placeholder="Email"
                />
                <button type="submit">Submit</button>
              </form>
              <div>
                <label>
                  <input
                    type="checkbox"
                    checked={checked}
                    onChange={() => setChecked((c) => !c)}
                  />
                  Enable feature
                </label>
              </div>
              <div>
                <input type="file" accept="image/*" onChange={handleAvatarUpload} />
                {avatar && <img src={avatar} alt="avatar" width={64} />}
              </div>
            </div>
          )}
          {tab === "users" && (
            <UserList
              users={filteredUsers}
              editUserId={editUserId}
              editUser={editUser}
              onEditUser={handleEditUser}
              onEditUserChange={handleEditUserChange}
              onSaveUser={handleSaveUser}
              onDeleteUser={handleDeleteUser}
              onCancelEdit={() => setEditUserId(null)}
              searchUser={searchUser}
              setSearchUser={setSearchUser}
            />
          )}
          {tab === "todos" && (
            <TodoList
              todos={filteredTodos}
              todoText={todoText}
              onTodoTextChange={setTodoText}
              onAddTodo={handleAddTodo}
              onToggleTodo={handleToggleTodo}
              onDeleteTodo={handleDeleteTodo}
              searchTodo={searchTodo}
              setSearchTodo={setSearchTodo}
              bulkSelect={bulkSelect}
              onBulkSelect={handleBulkSelect}
              showBulkActions={showBulkActions}
              setShowBulkActions={setShowBulkActions}
              onBulkDelete={handleBulkDelete}
            />
          )}
        </div>
      </div>
      <div>
        <h2>History</h2>
        <button onClick={() => dispatchHistory({ type: "undo" })}>Undo</button>
        <button onClick={() => dispatchHistory({ type: "redo" })}>Redo</button>
        <button onClick={() => setShowHistory((s) => !s)}>
          {showHistory ? "Hide" : "Show"} History
        </button>
        {showHistory && (
          <ul>
            {historyState.past.map((h, i) => (
              <li key={i}>{h}</li>
            ))}
            <li>
              <strong>{historyState.present}</strong>
            </li>
            {historyState.future.map((h, i) => (
              <li key={i + historyState.past.length + 1}>{h}</li>
            ))}
          </ul>
        )}
      </div>
      <div>
        <h2>API Data</h2>
        <button onClick={fetchApiData}>Fetch API Data</button>
        {apiLoading && <div>Loading...</div>}
        {error && <div style={{ color: "red" }}>{error}</div>}
        <ul>
          {apiData.map((d: any) => (
            <li key={d.id}>
              <strong>{d.title}</strong>
              <p>{d.body}</p>
            </li>
          ))}
        </ul>
      </div>
      <footer>
        <small>Generated by Copilot | Timer: {timer}s | Theme: {theme}</small>
      </footer>
    </div>
  );
};

export default MegaComponent;